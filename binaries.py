# FORSETI - Feature extractor and classificator for ELF binaries
# Author: Lucas Galante
# Advisor: Marcus Botacin, Andre Gregio, Paulo de Geus
# 2019, UFPR, UNICAMP

import sys  # fwrite function for printing
import pickle
import os
import ConfigParser # Configuration file for user

class Binary:
    def __init__(self,elf,label=None):
        #Elf name and path
        self.elf = elf
        #List containing discrete binary features
        self.discrete_list = []
        #List containg continuos binary information.
        self.continuous_list = []
        #List containing discrete binary features
        self.dynamic_discrete_list = []
        #List containg continuos binary information.
        self.dynamic_continuous_list = []
        #Goodware or malware label, None for default
        self.original_label = label
        #Testing label. Discovered label.
        self.determined_label = 'unset'
        #Saves objdump -T data from the binary
        self.objdumpT = None
        #Elffile data generated by pyelftools
        self.elffile = None
        #Strings data from the binary
        self.strings = None

    def getElf(self):
        return self.elf

    def getDiscreteList(self):
        return self.discrete_list

    def getContinuousList(self):
        return self.continuous_list

    def appendDiscreteList(self,feature):
        self.discrete_list.append(feature)

    def appendContinuousList(self,feature):
        self.continuous_list.append(feature)

    def getDynamicDiscreteList(self):
        return self.dynamic_discrete_list

    def getDynamicContinuousList(self):
        return self.dynamic_continuous_list

    def appendDynamicDiscreteList(self,feature):
        self.dynamic_discrete_list.append(feature)

    def appendDynamicContinuousList(self,feature):
        self.dynamic_continuous_list.append(feature)

    def getOriginalLabel(self):
        return self.original_label

    def getDeterminedLabel(self):
        return self.determined_label

    def setOriginalLabel(self,label):
        self.original_label = label

    def setDeterminedLabel(self,d_label):
        self.determined_label = d_label

    def getObjdumpT(self):
        return self.objdumpT

    def setObjdumpT(self,objdump):
        self.objdumpT = objdump

    def getStrings(self):
        return self.strings

    def setStrings(self,strings):
        self.strings = strings

    def getElfFile(self):
        return self.elffile

    def setElfFile(self,elffile):
        self.elffile = elffile


    def pickleDump(self):
        # Open user configuration file
        config = ConfigParser.RawConfigParser()
        config.read('forsite.conf')
        exists = os.path.isfile(config.get('Classifier','Binary-pickle')+os.path.basename(self.elf))
        if (exists):
            # Dont dump
            return
        try:
            # Data will be pickled to file
            pickle_out = open(config.get('Classifier','Binary-pickle')+os.path.basename(self.elf),"wb")
            # pickle.dump(self.__dict__,pickle_out)
            pickle.dump(self.discrete_list,pickle_out)
            pickle.dump(self.continuous_list,pickle_out)
            pickle_out.close()
        except:
            print("ERROR: \{BINARY.PY\} Unable to pickle dump.\n")

        return

    def pickleLoad(self):
        # Open user configuration file
        config = ConfigParser.RawConfigParser()
        config.read('forsite.conf')
        exists = os.path.isfile(config.get('Classifier','Binary-pickle')+os.path.basename(self.elf))
        if (not exists):
            # Dont load
            return
        try:
            # Data will be unpickled from file
            pickle_in = open(config.get('Classifier','Binary-pickle')+os.path.basename(self.elf),"rb")
            # temp_dict = pickle.load(pickle_in)
            self.discrete_list = pickle.load(pickle_in)
            self.continuous_list = pickle.load(pickle_in)
            pickle_in.close()
            # self.__dict__.update(temp_dict) # Update object to look like pickled one
            return 1
        except:
            print("ERROR: \{BINARY.PY\} Unable to pickle load.\n")
            return 0

    def dynamicDump(self):
        # Open user configuration file
        config = ConfigParser.RawConfigParser()
        config.read('forsite.conf')
        exists = os.path.isfile(config.get('Classifier','Dynamic-pickle')+os.path.basename(self.elf))
        if (exists):
            # Dont dump
            return
        try:
            # Data will be pickled to file
            pickle_out = open(config.get('Classifier','Dynamic-pickle')+os.path.basename(self.elf),"wb")
            # pickle.dump(self.__dict__,pickle_out)
            pickle.dump(self.dynamic_discrete_list,pickle_out)
            pickle.dump(self.dynamic_continuous_list,pickle_out)
            pickle_out.close()
        except:
            print("ERROR: \{BINARY.PY\} Unable to pickle dump.\n")

        return

    def dynamicLoad(self):
        # Open user configuration file
        config = ConfigParser.RawConfigParser()
        config.read('forsite.conf')
        exists = os.path.isfile(config.get('Classifier','Dynamic-pickle')+os.path.basename(self.elf))
        if (not exists):
            # Dont load
            return
        try:
            # Data will be unpickled from file
            pickle_in = open(config.get('Classifier','Dynamic-pickle')+os.path.basename(self.elf),"rb")
            # temp_dict = pickle.load(pickle_in)
            self.dynamic_discrete_list = pickle.load(pickle_in)
            self.dynamic_continuous_list = pickle.load(pickle_in)
            pickle_in.close()
            # self.__dict__.update(temp_dict) # Update object to look like pickled one
            return 1
        except:
            print("ERROR: \{BINARY.PY\} Unable to pickle load.\n")
            return 0

    def printBinary(self):
        sys.stdout.write("%s %s %s %s %s\n" % (self.elf,self.original_label,self.determined_label,str(self.dynamic_discrete_list),str(self.dynamic_continuous_list)))
        sys.stdout.flush()
